# -*- coding: utf8 -*-
## Copyright (c) 2017 Stefan Thesing
##
##This file is part of Zettels.
##
##Zettels is free software: you can redistribute it and/or modify
##it under the terms of the GNU General Public License as published by
##the Free Software Foundation, either version 3 of the License, or
##(at your option) any later version.
##
##Zettels is distributed in the hope that it will be useful,
##but WITHOUT ANY WARRANTY; without even the implied warranty of
##MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##GNU General Public License for more details.
##
##You should have received a copy of the GNU General Public License
##along with Zettels. If not, see http://www.gnu.org/licenses/.

import logging
import os

logger = logging.getLogger('Zettels.' + __name__)

class Zettelkasten:

    ######################
    # Constructor        #
    ######################
    def __init__(self, index, rootdir):
        """Inits Zettelkasten class
        
        :param index: an index of the Zettels generated by Zettelparser
        :param rootdir: path to the directory containing the Zettels
        """
        self.index = index
        self.rootdir = rootdir
        
    ######################
    # Operations         #
    ######################
    
    def get_list_of_zettels(self, as_output=False, outputformat='{0[0]:<50}| {0[1]}'):
        """
        Get a list of all Zettels from the index.
        
        :return: A list of Zettels. If as_output is set to True, the list 
            contains strings formated by outputformat. Otherwise, it contains 
            tuples. One tuple for each Zettel in the index.
            Each tuple contains:
            - Title of the Zettel
            - Path of the Zettel relative to rootdir
        """
        zettels = []
        for zettel in self.index['files']:
            tup = (self.index['files'][zettel]['title'], zettel)
            
            if as_output:
                zettels.append(outputformat.format(tup))
            else:
                zettels.append(tup)
        
        if as_output:
            zettels.sort(key=str.lower)
        
        return zettels
    
    def get_title_of(self, zettel):
        """
        Get the Title of a Zettel from the index.

        :param zettel: path to a Zettel file
        :return: Title of the Zettel as a String 
        """
        
        # Make the path to the file relative to the root directory
        zettel = os.path.relpath(zettel, self.rootdir)
        return self.index['files'][zettel]['title']
    
    def get_followups_of(self, zettel, as_output=False, outputformat='{0[0]:<40}| {0[1]}'):
        """
        Get the Followups of a Zettel from the index.

        :param zettel: path to a Zettel file
        :param index: An existing index.
        :return: A list of tuples. Each tuple contains:
            - Title of the followup
            - Path of the followup relative to rootdir
        """
        # First, absolute path of zettel
        # In fact, we need the real path (desolving symlinks)
        zettel = os.path.realpath(zettel)
        logger.debug("Real path to ZETTEL: " + str(zettel))
        
        # Make the path to the file relative to the root directory
        # To do that, we need the real path, too
        logger.debug("Real path to root Dir: " + str(os.path.realpath(self.rootdir)))
        
        zettel = os.path.relpath(zettel, os.path.realpath(self.rootdir))
        logger.debug("Relative path to ZETTEL: " + str(zettel))
        zetdir = os.path.dirname(zettel)
        logger.debug("Dirname of ZETTEL: " + str(zetdir))
        
        followups = []
        for followup in self.index['files'][zettel]['followups']:
            followup = os.path.normpath(os.path.join(zetdir, followup))
            tup = (self.index['files'][followup]['title'], followup)
            
            if as_output:
                followups.append(outputformat.format(tup))
            else:
                followups.append(tup)
        
        if as_output:
            followups.sort(key=str.lower)
        
        return followups
    
    def get_targets_of(self, zettel, as_output=False, outputformat='{0[0]:<40}| {0[1]}'):
        """
        Get the targets of a Zettel's hyperlinks from the index.

        :param zettel: path to a Zettel file
        :param index: An existing index.
        :return: A list of tuples. Each tuple contains:
            - Title of the target
            - Path of the target relative to rootdir
        """
        # First, real path of zettel
        zettel = os.path.realpath(zettel)
        
        # Make the path to the file relative to the root directory
        zettel = os.path.relpath(zettel, os.path.realpath(self.rootdir))
        zetdir = os.path.dirname(zettel)
        
        targets = []
        for target in self.index['files'][zettel]['targets']:
            # is it an intenal link to another zettel?
            try:
                normtarget = os.path.normpath(os.path.join(zetdir, target))
                tup = (self.index['files'][normtarget]['title'], normtarget)
            except KeyError:
                tup = ("External link", target)
                
            if as_output:
                targets.append(outputformat.format(tup))
            else:
                targets.append(tup)
        
        if as_output:
            targets.sort(key=str.lower)
        
        return targets
    
    def get_incoming_of(self, zettel, as_output=False, outputformat='{0[0]:<40}| {0[1]}'):
        """
        Get the Sources of incoming links to a Zettel from the index.

        :param zettel: path to a Zettel file
        :return: A list of tuples. Each tuple contains:
            - Title of the incoming link's source
            - Path of the source relative to rootdir
        """
        # First, real path of zettel
        zettel = os.path.realpath(zettel)
        
        # Make the path to the file relative to the root directory
        zettel = os.path.relpath(zettel, os.path.realpath(self.rootdir))
        zetdir = os.path.dirname(zettel)
        
        # Start with an empty list of sources
        sources = []
        
        # Iterate over the whole index
        for f in self.index['files']:
            # For every file, read the targets of its links, as well as 
            # its followups from index
              
            # empty lists
            targets = []
            followups = []
            
            # The dir part of f's path, relative to root dir
            fdir = os.path.dirname(f)
                        
            try:
                # Get the targets from index and replace the empty list
                # We could do the following:
                # targets = self.index['files'][f]['targets']
                # However, the links contained in targets are relative to the 
                # file f. We have to make them relative to rootdir. 
                # So we do this:
                for target in self.index['files'][f]['targets']:
                    targets.append(os.path.normpath(os.path.join(fdir, target)))
                
                # Same for followups
                for followup in self.index['files'][f]['followups']:
                    followups.append(os.path.normpath(os.path.join(fdir, followup)))
            except KeyError:
                # Throw an error if the index has no target property for 
                # the file in question. In that case we continue with the 
                # empty list, meaning we don't do anything
                logger.debug(f + "has no target property. That's a sign for \
                a malformed index. Continuing program, but expect output to \
                be wrong.")
                logger.debug(sys.exc_info()[1])
            
            # Check if our zettel file is among the targets. If so, 
            # write the current f to our list of sources
            if zettel in targets:
                tup = (self.index['files'][f]['title'], f)
                if as_output:
                    sources.append(outputformat.format(tup))
                else:
                    sources.append(tup)
            if zettel in followups:
                tup = (self.index['files'][f]['title'], f)
                if as_output:
                    sources.append(outputformat.format(tup))
                else:
                    sources.append(tup)
        
        # remove duplicates
        sources = list(set(sources))
        sources.sort()
        
        return sources
    
    def get_tags_of(self, zettel, as_output=False, outputformat='{0[0]:<40}| {0[1]}'):
        """
        Get the tags of a Zettel from the index.

        :param zettel: path to a Zettel file
        :param index: An existing index.
        :return: A list of tags
        """
        # First, real path of zettel
        zettel = os.path.realpath(zettel)
        
        # Make the path to the file relative to the root directory
        zettel = os.path.relpath(zettel, os.path.realpath(self.rootdir))
        zetdir = os.path.dirname(zettel)
        
        tags = []
        for tag in self.index['files'][zettel]['tags']:
            tags.append(tag)
        
        return tags
    
    def get_zettels_tagged_with(self, tag):
        """This function returns a list of Zettels contained in the index that 
        are tagged with the specified tag. The list actually
        contains tuples: Title of the file and the path to the file. 
        
        :param tag: the tag searched for
        :return: A list of tuples. Each tuple contains:
            - Title of the Zettel
            - Path to the Zettel as given in the index
        """
        # Start with an empy list
        taggedzettels = []
        # search index
        for f in index['files']:
            if tag in index['files'][f]['tags']:
                taggedzettels.append((index['files'][f]['title'],f))
        return taggedzettels
    